\section{Introduction}

Algorand is a platform for secure and decentralized digital currencies and transactions~\cite{Micali2019}. At the core of the Algorand platform is the Algorand consensus protocol~\cite{Chen2018,Chen2019}, a pure Proof-of-Stake (PoS) protocol that provides efficient, secure, and scalable operation while remaining decentralized. The basic idea in pure PoS is to make the security of the system dependent only on how honest the majority of its asset owners are, without having to rely on any specific subset of participants or having to lock up assets and penalize users.

Distributed consensus protocols are complex, and subject to general limitations even in non-adversarial settings~\cite{Fischer1985}. They typically involve interaction between many independent and potentially untrusted nodes in a large network where asynchronous and failure-prone communication is the norm rather than the exception.
Algorand, in particular, specifies not only the node-local behavior, but also deals with message propagation and delivery, to be able to address two types of attacks: (1) attacks that corrupt participating nodes so that they no longer follow the protocol, e.g., to produce fake transactions or to cast votes for the wrong transactions, and (2) attacks on the underlying network in which the system is deployed, for instance by intercepting, manipulating, and delaying messages. When an attacker gains full control of message delivery in a network, the network is said to be partitioned. Unlike Algorand, most existing consensus protocols do not consider what happens when a network is partitioned or after the network recovers from a partition.

Consensus systems are now the backbone of large cryptocurrencies worth billions of US dollars. This means that vulnerabilities can have catastrophic consequences. Consequently, ensuring correctness and resilience against malicious behavior while designing a consensus protocol is an important and challenging task. Having strong guarantees of correctness and developing a thorough understanding of protocol assumptions can significantly reduce the risk of catastrophic events.

In this report, we describe our effort to model and verify the Algorand consensus protocol using deductive verification. In this approach, systems are modeled and specified inside expressive formal logical systems, and verified in a similar way to how mathematicians prove theorems - in principle by elaborating proofs of statements step-by-step. In the spectrum of formal verification techniques, deductive verification provides the strongest guarantees, and thus the highest degree of trustworthiness, but at the expense of being the most demanding. Specifically, we use Coq~\cite{CoqArt}, a proof assistant developed for more than 30 years and used in several large-scale verification projects~\cite{Leroy2009,Woos2016}.

We developed a model of Algorand consensus in Coq in the form of a \emph{transition system}, over which we stated and ultimately proved the \emph{asynchronous safety} property: no two honest nodes certify two different blocks, even when the adversary has complete control of message delivery in the network. We also precisely pin down the assumptions under which the safety theorem holds. Beyond the safety theorem, we intend for this formalization to lay the foundation for further modeling and verification efforts related to the Algorand consensus protocol.

%Coq is developed for more than 30 years and very well supported. Coq has previously been used to develop a verified C compiler, formally prove mathematical results such as the four-color theorem, and verify distributed protocols (see, for example, our previous Casper formal verification effort for the Ethereum Foundation).

%We developed a model of the Algorand consensus protocol in Coq, a proof assistant based on type theory~\cite{}

%and proved a slew of its properties that we then used to ultimately show the asynchronous safety property: no two honest nodes certify two different blocks, even when the adversary has complete control of message delivery in the network.

%This report describes our effort to model the protocol and specify and verify its properties. Moreover, we describe the formalization of the assumptions under which the safety theorem holds. Beyond the safety theorem, we intend for this formalization in Coq to lay the foundation for further future modeling and verification efforts of the Algorand consensus protocol.

%A key characteristic of Algorand is that it almost never forks. Forking happens when consensus on a single block for a round is not reached and multiple candidate blocks are available for that round. Having different subsets of nodes decide on appending different blocks to the chain means that transactions appearing in these conflicting blocks are not finalized since only one of these blocks will eventually belong to the canonical chain, the chain that is deemed most accepted by the nodes (there are different methods for deciding the canonical chain, e.g. the longest chain in Bitcoin). Algorand avoids this problem by design: at most one block can receive the majority of votes in a round. This property implies that once a block of transactions appear in the chain, they can immediately be considered final. This has the potential of allowing extremely high levels of scalability. This no-forking property is referred to as Asynchronous safety, which states that no two honest nodes will certify two different blocks, even when the adversary has complete control of message delivery in the network. 
